import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as t,f as d,a as e,b as r,e as s}from"./app-1a70ebab.js";const a={},l=e("h1",{id:"回流-reflow-与重绘-repaint",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#回流-reflow-与重绘-repaint","aria-hidden":"true"},"#"),r(" 回流(reflow)与重绘(repaint)")],-1),o=s(`<h2 id="一、页面显示过程" tabindex="-1"><a class="header-anchor" href="#一、页面显示过程" aria-hidden="true">#</a> 一、页面显示过程</h2><ol><li><strong>生成DOM树(包括display:none的节点)</strong></li><li><strong>在DOM树的基础上根据节点的集合属性(margin,padding,width,height等)生成render树(不包括display:none，head节点，但是包括visibility:hidden的节点)</strong></li><li><strong>在render树的基础上继续渲染颜色背景色等样式</strong></li></ol><p><strong>reflow</strong>: 当render树的一部分或者全部因为大小边距等问题发生改变而需要重建的过程，叫做回流*</p><p><strong>repaint</strong>: 当诸如颜色背景等不会引起页面布局变化，而只需要重新渲染的过程叫做重绘*</p><h2 id="二、什么会引起回流" tabindex="-1"><a class="header-anchor" href="#二、什么会引起回流" aria-hidden="true">#</a> 二、什么会引起回流</h2><ol><li><strong>页面渲染初始化</strong></li><li><strong>DOM结构变化，比如删除了某个节点；</strong></li><li><strong>render树变化，比如减少了padding；</strong></li><li><strong>窗口resize事件触发</strong></li><li><strong>最复杂的一种：获取某些属性，引发回流</strong> 很多浏览器会对回流做优化，他会等到足够数量的变化发生，在做一次批处理回流。 <strong>但是除了render树的直接变化。</strong> 当获取一些属性时，浏览器为了获得正确的值也会触发回流。这样就使得浏览器的优化失效了*</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>这些属性包括：
    1. offsetTop, offsetLeft, offsetWidth, offsetHeight
    2. scrollTop/Left/Width/Height
    3. clientTop/Left/Width/Height
    4. width,height
    5. 调用了getComputedStyle(), 或者 IE的 currentStyle
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>举个例子：
    var s = document.body.style;
    s.padding = &quot;2px&quot;;   // 回流+重绘
    s.border = &quot;1px solid red&quot;;   // 再一次 回流+重绘
    s.color = &quot;blue&quot;;   // 再一次重绘
    s.backgroundColor = &quot;#ccc&quot;;  // 再一次 重绘
    s.fontSize = &quot;14px&quot;;   // 再一次 回流+重绘
    // 添加node，再一次 回流+重绘\`
    document.body.appendChild(document.createTextNode(&#39;abc!&#39;));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>可以看出，回流一定伴随着重绘，而重绘却可以单独出现</strong></p><h2 id="三、减少回流" tabindex="-1"><a class="header-anchor" href="#三、减少回流" aria-hidden="true">#</a> 三、减少回流</h2><ol><li>避免逐项更改样式。最好一次性更改style属性，或者将样式列表定义为class并一次性更改class属性。</li><li>避免循环操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document。</li><li>避免多次读取offsetLeft等属性。无法避免则将它们缓存到变量。</li><li>将复杂的元素绝对定位或固定定位，使它脱离文档流。否则回流代价十分高</li></ol><p><strong>补充：改变字体大小会引发回流</strong></p><h2 id="display-none和visibility-hidden会产生回流与重绘吗" tabindex="-1"><a class="header-anchor" href="#display-none和visibility-hidden会产生回流与重绘吗" aria-hidden="true">#</a> display:none和visibility：hidden会产生回流与重绘吗？</h2><p>display：none指的是元素完全不陈列出来，不占据空间，涉及到了DOM结构，故产生reflow与repaint</p><p>visibility：hidden指的是元素不可见但存在，保留空间，不影响结构，故只产生repaint</p>`,15);function c(h,u){return n(),t("div",null,[l,d(" more "),o])}const g=i(a,[["render",c],["__file","feflow-repaint.html.vue"]]);export{g as default};
